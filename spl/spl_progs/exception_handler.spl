//Exception Handler

[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = -1; //Setting mode flag to -1

[PROCESS_TABLE + ( [SYSTEM_STATUS_TABLE + 1] * 16) + 13] = SP; //Saving sp value in UPTR field
SP = [PROCESS_TABLE + ([SYSTEM_STATUS_TABLE + 1] * 16) + 11] * 512 - 1; //Setting up kernel stack

backup;
if (EC != 0) then 	//if cause is anything other than page falut
	backup;
	if (EC==1) then
		print "ILLEG_INSTR";
	else
		if (EC==2) then
			print "ILLEG_MEM_ACC";
		else
			if (EC==3) then
				print "ARITH_EXCP";
			endif;
		endif;
	endif;
	//call exit process
	R1 = 3;
	R2 = [SYSTEM_STATUS_TABLE + 1];
	call MOD_1;
	//call scheduler
	call MOD_5;
	restore;
endif;

if(EC==0) then
	//if page fault is caused due to code page
	if(EPN==4 || EPN==5 || EPN==6 || EPN==7) then //code page

		backup;
			R1=5;
			R2=[SYSTEM_STATUS_TABLE+1];
			R3=[DISK_MAP_TABLE + 10*[SYSTEM_STATUS_TABLE+1]+EPN]; //block number
			call MOD_2;
			
			[PAGE_TABLE_BASE+[SYSTEM_STATUS_TABLE+1]*20 + 2*EPN]=R0;
			[PAGE_TABLE_BASE+[SYSTEM_STATUS_TABLE+1]*20 + 2*EPN + 1]="1100";
		restore;
	endif;

	if(EPN==2 || EPN==3) then //heap page missing
		backup;
		R1=1;
		call MOD_2; //calling get new page
		[PAGE_TABLE_BASE+[SYSTEM_STATUS_TABLE+1]*20 + 2*EPN]=R0;
		[PAGE_TABLE_BASE+[SYSTEM_STATUS_TABLE+1]*20 + 2*EPN + 1]="1110";
		restore;
	endif;

endif;

restore;

[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 0; //Setting mode flag back to 0

//changing back to user stack
SP=[PROCESS_TABLE+([SYSTEM_STATUS_TABLE+1]*16)+13];
//breakpoint;
ireturn;